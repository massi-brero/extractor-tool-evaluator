package de.mbrero.see.parser;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import de.mbrero.see.persistance.dto.Annotation;
import types.OutputType;
import util.ProgressBar;

/**
 * Parses the content of the result xml generated by a annotation run.<br>
 * Since the results file may differ from extractor to extractor, this class will<br>
 * be extended by specific classes dealing with the specific structures of the extractor's output,
 * 
 * @author massimiliano.brero@studium.fernuni-hagen.de
 *
 */
public abstract class AbstractParser implements IAnnotationParser {

	/**
	 * The document to be parsed.
	 */
	protected Document document = null;

	/*
	 * Tag name in the result xml where the umls concepts are displayed. This
	 * class presumes the extractor result is in a well formed XML file.
	 */
	protected String conceptInformationTag = "";

	/*
	 * The tag where the id of the concept is stored. Some extractors only
	 * deliver the UMLS id (CUI) of a concept. Then this will be stored with
	 * {@link Annotation#setCui(String)}. Otherwise <br> the source vocabulary
	 * id will be stored in {@link Annotation#setConceptId(String)}. Anyway the
	 * ontology will and should for extending classes always be retrieved and
	 * stored.
	 * 
	 * With this attribute you define where the parser has to look for the id.
	 */
	protected String conceptIdentifierNode = "";

	/**
	 * The result xml from the cTakes run.
	 */
	protected File sourceFile;

	/**
	 * The ontology used for the prototype of this software. To get the used
	 * ontology dynamically from the MRCONSO.RFF file of <br/>
	 * a UMLS installation use {@link ParserHelper#getOntologyForCui(String)}.
	 * Beware the extraction from the usually big files is quite expensive.
	 */
	protected final String PROTOTYPE_ONTOLOGY = "NCBI";

	/**
	 * All annotations for every parsed result file. Structure
	 * {@link Annotation}:
	 * <ul>
	 * [document_id]
	 * <li>[cui 1] -> Annotation object</li>
	 * <li>[cui 1] -> Annotation object</li>
	 * <li>...</li>
	 * <ul>
	 * [document_id]
	 * <li>[cui 2] -> Annotation object</li>
	 * <li>[cui 1] -> Annotation object</li>
	 * <li>...</li>
	 */
	protected HashMap<String, HashMap<String, Annotation>> annotations;

	/*
	 * File for the parsed concepts.
	 */
	protected OutputType outputType = null;

	/**
	 * Where to write the TREC result file.
	 */
	protected File outputFile;
	protected String extractorName = "";

	public AbstractParser() {
		annotations = new HashMap<>();
		setInputFile(new File(""));
	}

	@Override
	public void read() throws FileNotFoundException {

	}

	/**
	 * Runs through the result xml file to find the tags containing the UMLS
	 * concept information.
	 * 
	 * If the path is pointing to a directory, all files in this folder will
	 * be parsed automatically.
	 * 
	 * If no annotations could be extracted from the file, we insert an "empty"
	 * annotation. This way later evaluation tools won't omit this file.
	 * 
	 * @see AbstractParser#getEmptyAnnotation()
	 * @throws Exception
	 */
	@Override
	public void parse(File source) throws Exception {
		setInputFile(source);

		if (getInputFile().isFile()) {
			HashMap<String, Annotation> parsedFilesAnnotations = parseFile();

			if (parsedFilesAnnotations.size() != 0) {
				getAnnotations().put(getAnnotatedFileName(), parsedFilesAnnotations);				
			} else {
				parsedFilesAnnotations.put("-1", getEmptyAnnotation());
				getAnnotations().put(getAnnotatedFileName(), parsedFilesAnnotations);
			}

		} else if (getInputFile().isDirectory()) {

			File[] files = getInputFile().listFiles();

			for (File file : files) {
				parse(file);
				System.out.println("\nFinished parsing file: " + file.getAbsolutePath());
			}

		} else {
			throw new FileNotFoundException("Could not parse given path!");
		}

	}

	/**
	 * Parse a single file... means: process the extractor's ouptput.
	 * @return
	 * @throws Exception
	 */
	protected HashMap<String, Annotation> parseFile() throws Exception {

		NodeList nList = getNodeList(conceptInformationTag);
		HashMap<String, Annotation> fileAnnotations = new HashMap<>();
		
		ProgressBar progressBar = new ProgressBar();
		
		for (int idx = 0; idx < nList.getLength(); idx++) {
			Annotation annotation = new Annotation();

			progressBar.showProgress(nList.getLength(), idx, 10);

			Node node = nList.item(idx);

			if (node.getNodeType() == Node.ELEMENT_NODE) {

				Element elem = (Element) node;

				if (getConceptIdentifierNode().isEmpty())
					throw new ParserConfigurationException("No tag where the concept id can be found was set");

				String conceptId = elem.getAttribute(getConceptIdentifierNode());

				annotation = buildAnnotation(elem, conceptId);

				if (fileAnnotations.get(conceptId) == null) {
					fileAnnotations.put(conceptId, annotation);
				} else {
					fileAnnotations.get(conceptId).incrementCounter();
				}
			}
		}

		return fileAnnotations;
	}

	/**
	 *  Reads the annotation tags. Validating the XML is turned of for performance reasons.
	 * 
	 * @param tagName
	 * @return
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * @throws IOException
	 */
	protected NodeList getNodeList(String tagName) throws ParserConfigurationException, SAXException, IOException {

		DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
		
		dbFactory.setNamespaceAware(false);
		dbFactory.setValidating(false);
		dbFactory.setFeature("http://xml.org/sax/features/namespaces", false);
		dbFactory.setFeature("http://xml.org/sax/features/validation", false);
		dbFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-dtd-grammar", false);
		dbFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);

		DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
		dBuilder.reset();
		document = dBuilder.parse(getInputFile());
		document.getDocumentElement().normalize();

		NodeList nList = document.getElementsByTagName(tagName);

		return nList;
	}

	/**
	 * Build the annotation in the needed form to be saved in a database table o r afile.
	 * 
	 * @param elem
	 * @param id
	 * @return
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * @throws IOException
	 * @throws Exception
	 */
	protected abstract Annotation buildAnnotation(Element elem, String id)
			throws ParserConfigurationException, SAXException, IOException, Exception;

	/**
	 * Get the name of the text that was annotated from the output of the concept mapper / extractor.
	 * 
	 * @return
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * @throws IOException
	 */
	protected abstract String getAnnotatedFileName() throws ParserConfigurationException, SAXException, IOException;

	/**
	 * 
	 * @return
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * @throws IOException
	 */
	private Annotation getEmptyAnnotation() throws ParserConfigurationException, SAXException, IOException 
	{

		Annotation annotation = new Annotation();

		annotation.setOntology("");
		annotation.setCui("-1");
		annotation.setPreferredText("");
		annotation.setDocumentID(getAnnotatedFileName());
		annotation.setExtractor(extractorName);
		annotation.setMatchedChunk("");
		annotation.setCount(1);

		return annotation;
	}
	/**
	 * 
	 * @param name
	 */
	public void setExtractorName(String name) {
		extractorName = name;
	}

	/**
	 * @return the extractorName
	 */
	public String getExtractorName() {
		return extractorName;
	}

	@Override
	public void setOutputType(OutputType type) {}

	/**
	 * @return the umlsInformationTagreturn
	 */
	public String getIdsInformationTag() {
		return conceptInformationTag;
	}

	/**
	 * @param umlsInformationTag
	 *            the umlsInformationTag to set
	 */
	public void setIdInformationTag(String umlsInformationTag) {
		this.conceptInformationTag = umlsInformationTag;
	}

	/**
	 * @return the annotations
	 */
	public HashMap<String, HashMap<String, Annotation>> getAnnotations() {
		return annotations;
	}

	/**
	 * @param annotations
	 *            the annotations to set
	 */
	public void setAnnotations(HashMap<String, HashMap<String, Annotation>> annotations) {
		this.annotations = annotations;
	}

	/**
	 * @return the outputFile
	 */
	public File getOutputFile() {
		return outputFile;
	}

	/**
	 * @return the inputFile
	 */
	public File getInputFile() {
		return sourceFile;
	}

	/**
	 * @param sourceFile
	 *            the inputFile to set
	 */
	public void setInputFile(File sourceFile) {
		this.sourceFile = sourceFile;
	}

	/**
	 * @param outputFile
	 *            the outputFile to set
	 */
	public void setOutputFile(File outputFile) {
		this.outputFile = outputFile;
	}

	/**
	 * @return the conceptIdTag
	 */
	public String getConceptIdentifierNode() {
		return conceptIdentifierNode;
	}

	/**
	 * @param conceptIdTag
	 *            the conceptIdTag to set
	 */
	public void setConceptIdentifierNode(String node) {
		this.conceptIdentifierNode = node;
	}

}
