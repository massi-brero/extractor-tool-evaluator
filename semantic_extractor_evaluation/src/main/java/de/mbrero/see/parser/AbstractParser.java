package de.mbrero.see.parser;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import de.mbrero.see.persistance.dto.Annotation;
import types.OutputType;

/**
 * Parses the content of the result xml generated by a ctakes annotation run.
 * 
 * @author massi.brero@gmail.com
 *
 */
public abstract class AbstractParser implements AnnotationParser {

	/**
	 * The document to be parsed.
	 */
	protected Document document = null;

	/*
	 * Tag name in the result xml where the umls concepts are displayed. This
	 * class presumes the extractor result is in a well formed XML file.
	 */
	protected String conceptInformationTag = "";

	/*
	 * The tag where the id of the concept is stored. Some extractors only
	 * deliver the UMLS id (CUI) of a concept. Then this will be stored with
	 * {@link Annotation#setCui(String)}. Otherwise <br> the source vocabulary
	 * id will be stored in {@link Annotation#setConceptId(String)}. Anyway the
	 * ontology will and should for extending classes always be retrieved and
	 * stored.
	 * 
	 * With this attribute you define where the parser has to look for the id.
	 */
	protected String conceptIdentifierNode = "";

	/**
	 * The result xml from the cTakes run.
	 */
	protected File sourceFile;

	/**
	 * All annotations for every parsed result file. Structure
	 * {@link Annotation}:
	 * <ul>
	 * [document_id]
	 * <li>[cui 1] -> Annotation object</li>
	 * <li>[cui 1] -> Annotation object</li>
	 * <li>...</li>
	 * <ul>
	 * [document_id]
	 * <li>[cui 2] -> Annotation object</li>
	 * <li>[cui 1] -> Annotation object</li>
	 * <li>...</li>
	 */
	protected HashMap<String, HashMap<String, Annotation>> annotations;

	/*
	 * File for the parsed concepts.
	 */
	protected OutputType outputType = null;

	/**
	 * Where to write the TREC result file.
	 */
	protected File outputFile;
	protected String extractorName = "";

	public AbstractParser() {
		annotations = new HashMap<>();
		setInputFile(new File(""));
	}

	@Override
	public void read() throws FileNotFoundException {

	}

	/**
	 * Runs through the result xml file to find the tags containing the UMLS
	 * concept information.
	 * 
	 * If the path is pointing to a directory, all files in this folder will
	 * be<br>
	 * parsed automatically
	 * 
	 * @throws Exception
	 */
	@Override
	public void parse(File source) throws Exception {
		setInputFile(source);

		if (getInputFile().isFile()) {

			getAnnotations().put(getAnnotatedFileName(), parseFile());

		} else if (getInputFile().isDirectory()) {

			File[] files = getInputFile().listFiles();

			for (File file : files) {
				parse(file);
				System.out.println("Finished parsing file: " + file.getAbsolutePath());
			}

		} else {
			throw new FileNotFoundException("Could not parse given path!");
		}

	}

	protected HashMap<String, Annotation> parseFile() throws Exception {

		NodeList nList = getNodeList(conceptInformationTag);
		HashMap<String, Annotation> fileAnnotations = new HashMap<>();

		for (int idx = 0; idx < nList.getLength(); idx++) {
			Annotation annotation = new Annotation();

			Node node = nList.item(idx);

			if (node.getNodeType() == Node.ELEMENT_NODE) {

				Element elem = (Element) node;

				if (getConceptIdentifierNode().isEmpty())
					throw new ParserConfigurationException("No tag where the concept id can be found was set");

				String conceptId = elem.getAttribute(getConceptIdentifierNode());

				annotation = buildAnnotation(elem, conceptId);

				if (fileAnnotations.get(conceptId) == null) {
					fileAnnotations.put(conceptId, annotation);
				} else {
					fileAnnotations.get(conceptId).incrementCounter();
				}
			}
		}

		return fileAnnotations;
	}

	protected NodeList getNodeList(String tagName) throws ParserConfigurationException, SAXException, IOException {

		DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
		DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
		dBuilder.reset();
		document = dBuilder.parse(getInputFile());
		document.getDocumentElement().normalize();

		NodeList nList = document.getElementsByTagName(tagName);

		return nList;
	}

	protected abstract Annotation buildAnnotation(Element elem, String id)
			throws ParserConfigurationException, SAXException, IOException, Exception;

	protected abstract String getAnnotatedFileName() throws ParserConfigurationException, SAXException, IOException;

	/**
	 * 
	 * @param name
	 */
	public void setExtractorName(String name) {
		extractorName = name;
	}

	/**
	 * @return the extractorName
	 */
	public String getExtractorName() {
		return extractorName;
	}

	@Override
	public void setOutputType(OutputType type) {
		// TODO Auto-generated method stub

	}

	/**
	 * @return the umlsInformationTagreturn
	 */
	public String getIdsInformationTag() {
		return conceptInformationTag;
	}

	/**
	 * @param umlsInformationTag
	 *            the umlsInformationTag to set
	 */
	public void setIdInformationTag(String umlsInformationTag) {
		this.conceptInformationTag = umlsInformationTag;
	}

	/**
	 * @return the annotations
	 */
	public HashMap<String, HashMap<String, Annotation>> getAnnotations() {
		return annotations;
	}

	/**
	 * @param annotations
	 *            the annotations to set
	 */
	public void setAnnotations(HashMap<String, HashMap<String, Annotation>> annotations) {
		this.annotations = annotations;
	}

	/**
	 * @return the outputFile
	 */
	public File getOutputFile() {
		return outputFile;
	}

	/**
	 * @return the inputFile
	 */
	public File getInputFile() {
		return sourceFile;
	}

	/**
	 * @param sourceFile
	 *            the inputFile to set
	 */
	public void setInputFile(File sourceFile) {
		this.sourceFile = sourceFile;
	}

	/**
	 * @param outputFile
	 *            the outputFile to set
	 */
	public void setOutputFile(File outputFile) {
		this.outputFile = outputFile;
	}

	/**
	 * @return the conceptIdTag
	 */
	public String getConceptIdentifierNode() {
		return conceptIdentifierNode;
	}

	/**
	 * @param conceptIdTag
	 *            the conceptIdTag to set
	 */
	public void setConceptIdentifierNode(String node) {
		this.conceptIdentifierNode = node;
	}

}
